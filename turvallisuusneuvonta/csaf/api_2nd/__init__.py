# generated by datamodel-codegen:
#   filename:  csaf_2_0.json
#   timestamp: 2021-12-29T15:01:38+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Annotated, List, Optional, Union

from pydantic import AnyUrl, BaseModel, Field

import turvallisuusneuvonta.csaf.api_2nd.cvss_v2 as cvss_v2
import turvallisuusneuvonta.csaf.api_2nd.cvss_v3 as cvss_v3


class AggregateSeverity(BaseModel):
    namespace: Annotated[
        Optional[AnyUrl],
        Field(
            description='Points to the namespace so referenced.',
            title='Namespace of aggregate severity',
        ),
    ] = None
    text: Annotated[
        str,
        Field(
            description=(
                'Provides a severity which is independent of - and in addition to - any other standard metric for'
                ' determining the impact or severity of a given vulnerability (such as CVSS).'
            ),
            examples=['Critical', 'Important', 'Moderate'],
            min_length=1,
            title='Text of aggregate severity',
        ),
    ]


class CsafVersion(Enum):
    field_2_0 = '2.0'


class Label(Enum):
    AMBER = 'AMBER'
    GREEN = 'GREEN'
    RED = 'RED'
    WHITE = 'WHITE'


class Tlp(BaseModel):
    label: Annotated[
        Label,
        Field(description='Provides the TLP label of the document.', title='Label of TLP'),
    ]
    url: Annotated[
        Optional[AnyUrl],
        Field(
            description=(
                'Provides a URL where to find the textual description of the TLP version which is used'
                ' in this document. Default is the URL to the definition by FIRST.'
            ),
            examples=[
                'https://www.us-cert.gov/tlp',
                'https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Kritis/Merkblatt_TLP.pdf',
            ],
            title='URL of TLP version',
        ),
    ] = AnyUrl('https://www.first.org/tlp/')


class Distribution(BaseModel):
    text: Annotated[
        Optional[str],
        Field(
            description='Provides a textual description of additional constraints.',
            examples=[
                'Copyright 2021, Example Company, All Rights Reserved.',
                'Distribute freely.',
                'Share only on a need-to-know-basis only.',
            ],
            min_length=1,
            title='Textual description',
        ),
    ] = None
    tlp: Annotated[
        Optional[Tlp],
        Field(
            description='Provides details about the TLP classification of the document.',
            title='Traffic Light Protocol (TLP)',
        ),
    ] = None


class Category(Enum):
    coordinator = 'coordinator'
    discoverer = 'discoverer'
    other = 'other'
    translator = 'translator'
    user = 'user'
    vendor = 'vendor'


class Publisher(BaseModel):
    category: Annotated[
        Category,
        Field(
            description='Provides information about the category of publisher releasing the document.',
            title='Category of publisher',
        ),
    ]
    contact_details: Annotated[
        Optional[str],
        Field(
            description=(
                'Information on how to contact the publisher, possibly including details such as web sites,'
                ' email addresses, phone numbers, and postal mail addresses.'
            ),
            examples=[
                'Example Company can be reached at contact_us@example.com, or via our website'
                ' at https://www.example.com/contact.'
            ],
            min_length=1,
            title='Contact details',
        ),
    ] = None
    issuing_authority: Annotated[
        Optional[str],
        Field(
            description=(
                'Provides information about the authority of the issuing party to release the document, in particular,'
                " the party's constituency and responsibilities or other obligations."
            ),
            min_length=1,
            title='Issuing authority',
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description='Contains the name of the issuing party.',
            examples=['BSI', 'Cisco PSIRT', 'Siemens ProductCERT'],
            min_length=1,
            title='Name of publisher',
        ),
    ]
    namespace: Annotated[
        AnyUrl,
        Field(
            description=(
                'Contains a URL which is under control of the issuing party and can be used as a globally'
                ' unique identifier for that issuing party.'
            ),
            examples=['https://csaf.io', 'https://www.example.com'],
            title='Namespace of publisher',
        ),
    ]


class Alias(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description=(
                'Specifies a non-empty string that represents a distinct optional alternative ID used to'
                ' refer to the document.'
            ),
            examples=['CVE-2019-12345'],
            min_length=1,
            title='Alternate name',
        ),
    ]


class Engine(BaseModel):
    name: Annotated[
        str,
        Field(
            description='Represents the name of the engine that generated the CSAF document.',
            examples=['Red Hat rhsa-to-cvrf', 'Secvisogram', 'TVCE'],
            min_length=1,
            title='Engine name',
        ),
    ]
    version: Annotated[
        Optional[str],
        Field(
            description='Contains the version of the engine that generated the CSAF document.',
            examples=['0.6.0', '1.0.0-beta+exp.sha.a1c44f85', '2'],
            min_length=1,
            title='Engine version',
        ),
    ] = None


class Generator(BaseModel):
    date: Annotated[
        Optional[datetime],
        Field(
            description=(
                'This SHOULD be the current date that the document was generated. Because documents are often'
                ' generated internally by a document producer and exist for a nonzero amount of time before'
                ' being released, this field MAY be different from the Initial Release Date and Current Release Date.'
            ),
            title='Date of document generation',
        ),
    ] = None
    engine: Annotated[
        Engine,
        Field(
            description='Contains information about the engine that generated the CSAF document.',
            title='Engine of document generation',
        ),
    ]


class Status(Enum):
    draft = 'draft'
    final = 'final'
    interim = 'interim'


class Category1(Enum):
    default_component_of = 'default_component_of'
    external_component_of = 'external_component_of'
    installed_on = 'installed_on'
    installed_with = 'installed_with'
    optional_component_of = 'optional_component_of'


class Cwe(BaseModel):
    id: Annotated[
        str,
        Field(
            description='Holds the ID for the weakness associated.',
            examples=['CWE-22', 'CWE-352', 'CWE-79'],
            regex='^CWE-[1-9]\\d{0,5}$',
            title='Weakness ID',
        ),
    ]
    name: Annotated[
        str,
        Field(
            description='Holds the full name of the weakness as given in the CWE specification.',
            examples=[
                'Cross-Site Request Forgery (CSRF)',
                "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
                "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
            ],
            min_length=1,
            title='Weakness name',
        ),
    ]


class Id(BaseModel):
    system_name: Annotated[
        str,
        Field(
            description='Indicates the name of the vulnerability tracking or numbering system.',
            examples=['Cisco Bug ID', 'GitHub Issue'],
            min_length=1,
            title='System name',
        ),
    ]
    text: Annotated[
        str,
        Field(
            description='Is unique label or tracking ID for the vulnerability (if such information exists).',
            examples=['CSCso66472', 'oasis-tcs/csaf#210'],
            min_length=1,
            title='Text',
        ),
    ]


class Party(Enum):
    coordinator = 'coordinator'
    discoverer = 'discoverer'
    other = 'other'
    user = 'user'
    vendor = 'vendor'


class Status1(Enum):
    completed = 'completed'
    contact_attempted = 'contact_attempted'
    disputed = 'disputed'
    in_progress = 'in_progress'
    not_contacted = 'not_contacted'
    open = 'open'


class Involvement(BaseModel):
    date: Annotated[
        Optional[datetime],
        Field(
            description='Holds the date and time of the involvement entry.',
            title='Date of involvement',
        ),
    ] = None
    party: Annotated[
        Party,
        Field(
            description='Defines the category of the involved party.',
            title='Party category',
        ),
    ]
    status: Annotated[
        Status1,
        Field(
            description='Defines contact status of the involved party.',
            title='Party status',
        ),
    ]
    summary: Annotated[
        Optional[str],
        Field(
            description='Contains additional context regarding what is going on.',
            min_length=1,
            title='Summary of the involvement',
        ),
    ] = None


class Category2(Enum):
    mitigation = 'mitigation'
    no_fix_planned = 'no_fix_planned'
    none_available = 'none_available'
    vendor_fix = 'vendor_fix'
    workaround = 'workaround'


class Entitlement(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description=(
                'Contains any possible vendor-defined constraints for obtaining fixed software or hardware that'
                ' fully resolves the vulnerability.'
            ),
            min_length=1,
            title='Entitlement of the remediation',
        ),
    ]


class Category3(Enum):
    connected = 'connected'
    dependencies = 'dependencies'
    machine = 'machine'
    none = 'none'
    parent = 'parent'
    service = 'service'
    system = 'system'
    vulnerable_component = 'vulnerable_component'
    zone = 'zone'


class RestartRequired(BaseModel):
    category: Annotated[
        Category3,
        Field(
            description='Specifies what category of restart is required by this remediation to become effective.',
            title='Category of restart',
        ),
    ]
    details: Annotated[
        Optional[str],
        Field(
            description=(
                'Provides additional information for the restart. This can include details on procedures,'
                ' scope or impact.'
            ),
            min_length=1,
            title='Additional restart information',
        ),
    ] = None


class Category4(Enum):
    exploit_status = 'exploit_status'
    impact = 'impact'
    target_set = 'target_set'


class AccessVectorType(Enum):
    NETWORK = 'NETWORK'
    ADJACENT_NETWORK = 'ADJACENT_NETWORK'
    LOCAL = 'LOCAL'


class AccessComplexityType(Enum):
    HIGH = 'HIGH'
    MEDIUM = 'MEDIUM'
    LOW = 'LOW'


class AuthenticationType(Enum):
    MULTIPLE = 'MULTIPLE'
    SINGLE = 'SINGLE'
    NONE = 'NONE'


class CiaType(Enum):
    NONE = 'NONE'
    PARTIAL = 'PARTIAL'
    COMPLETE = 'COMPLETE'


class ExploitabilityType(Enum):
    UNPROVEN = 'UNPROVEN'
    PROOF_OF_CONCEPT = 'PROOF_OF_CONCEPT'
    FUNCTIONAL = 'FUNCTIONAL'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class RemediationLevelType(Enum):
    OFFICIAL_FIX = 'OFFICIAL_FIX'
    TEMPORARY_FIX = 'TEMPORARY_FIX'
    WORKAROUND = 'WORKAROUND'
    UNAVAILABLE = 'UNAVAILABLE'
    NOT_DEFINED = 'NOT_DEFINED'


class ReportConfidenceType(Enum):
    UNCONFIRMED = 'UNCONFIRMED'
    UNCORROBORATED = 'UNCORROBORATED'
    CONFIRMED = 'CONFIRMED'
    NOT_DEFINED = 'NOT_DEFINED'


class CollateralDamagePotentialType(Enum):
    NONE = 'NONE'
    LOW = 'LOW'
    LOW_MEDIUM = 'LOW_MEDIUM'
    MEDIUM_HIGH = 'MEDIUM_HIGH'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class TargetDistributionType(Enum):
    NONE = 'NONE'
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class CiaRequirementType(Enum):
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class ScoreType(BaseModel):
    __root__: Annotated[float, Field(ge=0.0, le=10.0)]


class AttackVectorType(Enum):
    NETWORK = 'NETWORK'
    ADJACENT_NETWORK = 'ADJACENT_NETWORK'
    LOCAL = 'LOCAL'
    PHYSICAL = 'PHYSICAL'


class ModifiedAttackVectorType(Enum):
    NETWORK = 'NETWORK'
    ADJACENT_NETWORK = 'ADJACENT_NETWORK'
    LOCAL = 'LOCAL'
    PHYSICAL = 'PHYSICAL'
    NOT_DEFINED = 'NOT_DEFINED'


class AttackComplexityType(Enum):
    HIGH = 'HIGH'
    LOW = 'LOW'


class ModifiedAttackComplexityType(Enum):
    HIGH = 'HIGH'
    LOW = 'LOW'
    NOT_DEFINED = 'NOT_DEFINED'


class PrivilegesRequiredType(Enum):
    HIGH = 'HIGH'
    LOW = 'LOW'
    NONE = 'NONE'


class ModifiedPrivilegesRequiredType(Enum):
    HIGH = 'HIGH'
    LOW = 'LOW'
    NONE = 'NONE'
    NOT_DEFINED = 'NOT_DEFINED'


class UserInteractionType(Enum):
    NONE = 'NONE'
    REQUIRED = 'REQUIRED'


class ModifiedUserInteractionType(Enum):
    NONE = 'NONE'
    REQUIRED = 'REQUIRED'
    NOT_DEFINED = 'NOT_DEFINED'


class ScopeType(Enum):
    UNCHANGED = 'UNCHANGED'
    CHANGED = 'CHANGED'


class ModifiedScopeType(Enum):
    UNCHANGED = 'UNCHANGED'
    CHANGED = 'CHANGED'
    NOT_DEFINED = 'NOT_DEFINED'


class CiaTypeModel(Enum):
    NONE = 'NONE'
    LOW = 'LOW'
    HIGH = 'HIGH'


class ModifiedCiaType(Enum):
    NONE = 'NONE'
    LOW = 'LOW'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class ExploitCodeMaturityType(Enum):
    UNPROVEN = 'UNPROVEN'
    PROOF_OF_CONCEPT = 'PROOF_OF_CONCEPT'
    FUNCTIONAL = 'FUNCTIONAL'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class RemediationLevelTypeModel(Enum):
    OFFICIAL_FIX = 'OFFICIAL_FIX'
    TEMPORARY_FIX = 'TEMPORARY_FIX'
    WORKAROUND = 'WORKAROUND'
    UNAVAILABLE = 'UNAVAILABLE'
    NOT_DEFINED = 'NOT_DEFINED'


class ConfidenceType(Enum):
    UNKNOWN = 'UNKNOWN'
    REASONABLE = 'REASONABLE'
    CONFIRMED = 'CONFIRMED'
    NOT_DEFINED = 'NOT_DEFINED'


class CiaRequirementTypeModel(Enum):
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class ScoreTypeModel(BaseModel):
    __root__: Annotated[float, Field(ge=0.0, le=10.0)]


class SeverityType(Enum):
    NONE = 'NONE'
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    CRITICAL = 'CRITICAL'


class AttackVectorTypeModel(Enum):
    NETWORK = 'NETWORK'
    ADJACENT_NETWORK = 'ADJACENT_NETWORK'
    LOCAL = 'LOCAL'
    PHYSICAL = 'PHYSICAL'


class ModifiedAttackVectorTypeModel(Enum):
    NETWORK = 'NETWORK'
    ADJACENT_NETWORK = 'ADJACENT_NETWORK'
    LOCAL = 'LOCAL'
    PHYSICAL = 'PHYSICAL'
    NOT_DEFINED = 'NOT_DEFINED'


class AttackComplexityTypeModel(Enum):
    HIGH = 'HIGH'
    LOW = 'LOW'


class ModifiedAttackComplexityTypeModel(Enum):
    HIGH = 'HIGH'
    LOW = 'LOW'
    NOT_DEFINED = 'NOT_DEFINED'


class PrivilegesRequiredTypeModel(Enum):
    HIGH = 'HIGH'
    LOW = 'LOW'
    NONE = 'NONE'


class ModifiedPrivilegesRequiredTypeModel(Enum):
    HIGH = 'HIGH'
    LOW = 'LOW'
    NONE = 'NONE'
    NOT_DEFINED = 'NOT_DEFINED'


class UserInteractionTypeModel(Enum):
    NONE = 'NONE'
    REQUIRED = 'REQUIRED'


class ModifiedUserInteractionTypeModel(Enum):
    NONE = 'NONE'
    REQUIRED = 'REQUIRED'
    NOT_DEFINED = 'NOT_DEFINED'


class ScopeTypeModel(Enum):
    UNCHANGED = 'UNCHANGED'
    CHANGED = 'CHANGED'


class ModifiedScopeTypeModel(Enum):
    UNCHANGED = 'UNCHANGED'
    CHANGED = 'CHANGED'
    NOT_DEFINED = 'NOT_DEFINED'


class CiaTypeModel1(Enum):
    NONE = 'NONE'
    LOW = 'LOW'
    HIGH = 'HIGH'


class ModifiedCiaTypeModel(Enum):
    NONE = 'NONE'
    LOW = 'LOW'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class ExploitCodeMaturityTypeModel(Enum):
    UNPROVEN = 'UNPROVEN'
    PROOF_OF_CONCEPT = 'PROOF_OF_CONCEPT'
    FUNCTIONAL = 'FUNCTIONAL'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class RemediationLevelTypeModel1(Enum):
    OFFICIAL_FIX = 'OFFICIAL_FIX'
    TEMPORARY_FIX = 'TEMPORARY_FIX'
    WORKAROUND = 'WORKAROUND'
    UNAVAILABLE = 'UNAVAILABLE'
    NOT_DEFINED = 'NOT_DEFINED'


class ConfidenceTypeModel(Enum):
    UNKNOWN = 'UNKNOWN'
    REASONABLE = 'REASONABLE'
    CONFIRMED = 'CONFIRMED'
    NOT_DEFINED = 'NOT_DEFINED'


class CiaRequirementTypeModel1(Enum):
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    NOT_DEFINED = 'NOT_DEFINED'


class ScoreTypeModel1(BaseModel):
    __root__: Annotated[float, Field(ge=0.0, le=10.0)]


class SeverityTypeModel(Enum):
    NONE = 'NONE'
    LOW = 'LOW'
    MEDIUM = 'MEDIUM'
    HIGH = 'HIGH'
    CRITICAL = 'CRITICAL'


class Name(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description='Contains the name of a single person.',
            examples=['Albert Einstein', 'Johann Sebastian Bach'],
            min_length=1,
            title='Name of entity being recognized',
        ),
    ]


class AcknowledgmentsTItem(BaseModel):
    names: Annotated[
        Optional[List[Name]],
        Field(
            description='Contains the names of entities being recognized.',
            min_items=1,
            title='List of acknowledged names',
        ),
    ] = None
    organization: Annotated[
        Optional[str],
        Field(
            description='Contains the name of a contributing organization being recognized.',
            examples=['CISA', 'Google Project Zero', 'Talos'],
            min_length=1,
            title='Contributing organization',
        ),
    ] = None
    summary: Annotated[
        Optional[str],
        Field(
            description=(
                'SHOULD represent any contextual details the document producers wish to make known about'
                ' the acknowledgment or acknowledged parties.'
            ),
            examples=['First analysis of Coordinated Multi-Stream Attack (CMSA)'],
            min_length=1,
            title='Summary of the acknowledgment',
        ),
    ] = None
    urls: Annotated[
        Optional[List[AnyUrl]],
        Field(
            description='Specifies a list of URLs or location of the reference to be acknowledged.',
            min_items=1,
            title='List of URLs',
        ),
    ] = None


class AcknowledgmentsT(BaseModel):
    __root__: Annotated[
        List[AcknowledgmentsTItem],
        Field(
            description='Contains a list of acknowledgment elements.',
            min_items=1,
            title='List of acknowledgments',
        ),
    ]


class Category5(Enum):
    architecture = 'architecture'
    host_name = 'host_name'
    language = 'language'
    legacy = 'legacy'
    patch_level = 'patch_level'
    product_family = 'product_family'
    product_name = 'product_name'
    product_version = 'product_version'
    service_pack = 'service_pack'
    specification = 'specification'
    vendor = 'vendor'


class FileHash(BaseModel):
    algorithm: Annotated[
        str,
        Field(
            description='Contains the name of the cryptographic hash algorithm used to calculate the value.',
            examples=['blake2b512', 'sha256', 'sha3-512', 'sha384', 'sha512'],
            min_length=1,
            title='Algorithm of the cryptographic hash',
        ),
    ]
    value: Annotated[
        str,
        Field(
            description='Contains the cryptographic hash value in hexadecimal representation.',
            examples=[
                (
                    '37df33cb7464da5c7f077f4d56a32bc84987ec1d85b234537c1c1a4d4fc8d09d'
                    'c29e2e762cb5203677bf849a2855a0283710f1f5fe1d6ce8d5ac85c645d0fcb3'
                ),
                '4775203615d9534a8bfca96a93dc8b461a489f69124a130d786b42204f3341cc',
                '9ea4c8200113d49d26505da0e02e2f49055dc078d1ad7a419b32e291c7afebbb84badfbd46dec42883bea0b2a1fa697c',
            ],
            min_length=32,
            regex='^[0-9a-fA-F]{32,}$',
            title='Value of the cryptographic hash',
        ),
    ]


class Hash(BaseModel):
    file_hashes: Annotated[
        List[FileHash],
        Field(
            description='Contains a list of cryptographic hashes for this file.',
            min_items=1,
            title='List of file hashes',
        ),
    ]
    filename: Annotated[
        str,
        Field(
            description='Contains the name of the file which is identified by the hash values.',
            examples=['WINWORD.EXE', 'msotadddin.dll', 'sudoers.so'],
            min_length=1,
            title='Filename',
        ),
    ]


class SerialNumber(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description='Contains a part, or a full serial number of the component to identify.',
            min_length=1,
            title='Serial number',
        ),
    ]


class Sku(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description=(
                'Contains a part, or a full stock keeping unit (SKU) which is used in the ordering process to'
                ' identify the component.'
            ),
            min_length=1,
            title='Stock keeping unit',
        ),
    ]


class XGenericUri(BaseModel):
    namespace: Annotated[
        AnyUrl,
        Field(
            description=(
                'Refers to a URL which provides the name and knowledge about the specification used or is'
                ' the namespace in which these values are valid.'
            ),
            title='Namespace of the generic URI',
        ),
    ]
    uri: Annotated[AnyUrl, Field(description='Contains the identifier itself.', title='URI')]


class ProductIdentificationHelper(BaseModel):
    cpe: Annotated[
        Optional[str],
        Field(
            description=(
                'The Common Platform Enumeration (CPE) attribute refers to a method for naming platforms external'
                ' to this specification.'
            ),
            min_length=5,
            regex=(
                '^(cpe:2\\.3:[aho\\*\\-](:(((\\?*|\\*?)([a-zA-Z0-9\\-\\._]|'
                '(\\\\[\\\\\\*\\?!"#\\$%&\'\\(\\)\\+,/:;<=>@\\[\\]\\^`\\{\\|\\}~]))+(\\?*|\\*?))|[\\*\\-])){5}'
                '(:(([a-zA-Z]{2,3}(-([a-zA-Z]{2}|[0-9]{3}))?)|[\\*\\-]))(:(((\\?*|\\*?)([a-zA-Z0-9\\-\\._]|'
                '(\\\\[\\\\\\*\\?!"#\\$%&\'\\(\\)\\+,/:;<=>@\\[\\]\\^`\\{\\|\\}~]))+(\\?*|\\*?))|[\\*\\-])){4})|'
                '([c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\\._\\-~%]*){0,6})$'
            ),
            title='Common Platform Enumeration representation',
        ),
    ] = None
    hashes: Annotated[
        Optional[List[Hash]],
        Field(
            description='Contains a list of cryptographic hashes usable to identify files.',
            min_items=1,
            title='List of hashes',
        ),
    ] = None
    purl: Annotated[
        Optional[AnyUrl],
        Field(
            description=(
                'The package URL (purl) attribute refers to a method for reliably identifying and locating'
                ' software packages external to this specification.'
            ),
            min_length=7,
            regex='^pkg:[A-Za-z\\.\\-\\+][A-Za-z0-9\\.\\-\\+]*/.+',
            title='package URL representation',
        ),
    ] = None
    sbom_urls: Annotated[
        Optional[List[AnyUrl]],
        Field(
            description='Contains a list of URLs where SBOMs for this product can be retrieved.',
            min_items=1,
            title='List of SBOM URLs',
        ),
    ] = None
    serial_numbers: Annotated[
        Optional[List[SerialNumber]],
        Field(
            description='Contains a list of parts, or full serial numbers.',
            min_items=1,
            title='List of serial numbers',
        ),
    ] = None
    skus: Annotated[
        Optional[List[Sku]],
        Field(
            description='Contains a list of parts, or full stock keeping units.',
            min_items=1,
            title='List of stock keeping units',
        ),
    ] = None
    x_generic_uris: Annotated[
        Optional[List[XGenericUri]],
        Field(
            description=(
                'Contains a list of identifiers which are either vendor-specific or derived from a standard'
                ' not yet supported.'
            ),
            min_items=1,
            title='List of generic URIs',
        ),
    ] = None


class LangT(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description=(
                'Identifies a language, corresponding to IETF BCP 47 / RFC 5646. See IETF language registry:'
                ' https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry'
            ),
            examples=['de', 'en', 'fr', 'frc', 'jp'],
            regex=(
                '^(([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?|[A-Za-z]{4,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|'
                '[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-[A-WY-Za-wy-z0-9](-[A-Za-z0-9]{2,8})+)*'
                '(-[Xx](-[A-Za-z0-9]{1,8})+)?|[Xx](-[A-Za-z0-9]{1,8})+|'
                '[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Mm][Ii][Nn][Gg][Oo])$'
            ),
            title='Language type',
        ),
    ]


class Category6(Enum):
    description = 'description'
    details = 'details'
    faq = 'faq'
    general = 'general'
    legal_disclaimer = 'legal_disclaimer'
    other = 'other'
    summary = 'summary'


class NotesTItem(BaseModel):
    audience: Annotated[
        Optional[str],
        Field(
            description='Indicate who is intended to read it.',
            examples=[
                'all',
                'executives',
                'operational management and system administrators',
                'safety engineers',
            ],
            min_length=1,
            title='Audience of note',
        ),
    ] = None
    category: Annotated[
        Category6,
        Field(description='Choice of what kind of note this is.', title='Note category'),
    ]
    text: Annotated[
        str,
        Field(
            description='The contents of the note. Content varies depending on type.',
            min_length=1,
            title='Note contents',
        ),
    ]
    title: Annotated[
        Optional[str],
        Field(
            description='Provides a concise description of what is contained in the text of the note.',
            examples=[
                'Details',
                'Executive summary',
                'Technical summary',
                'Impact on safety systems',
            ],
            min_length=1,
            title='Title of note',
        ),
    ] = None


class NotesT(BaseModel):
    __root__: Annotated[
        List[NotesTItem],
        Field(
            description='Contains notes which are specific to the current context.',
            min_items=1,
            title='List of notes',
        ),
    ]


class ProductGroupIdT(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description=(
                'Token required to identify a group of products so that it can be referred to from other parts'
                ' in the document. There is no predefined or required format for the product_group_id as long'
                ' as it uniquely identifies a group in the context of the current document.'
            ),
            examples=['CSAFGID-0001', 'CSAFGID-0002', 'CSAFGID-0020'],
            min_length=1,
            title='Reference token for product group instance',
        ),
    ]


class ProductGroupsT(BaseModel):
    __root__: Annotated[
        List[ProductGroupIdT],
        Field(
            description='Specifies a list of product_group_ids to give context to the parent item.',
            min_items=1,
            title='List of product_group_ids',
        ),
    ]


class ProductIdT(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description=(
                'Token required to identify a full_product_name so that it can be referred to from other parts'
                ' in the document. There is no predefined or required format for the product_id as long as it'
                ' uniquely identifies a product in the context of the current document.'
            ),
            examples=['CSAFPID-0004', 'CSAFPID-0008'],
            min_length=1,
            title='Reference token for product instance',
        ),
    ]


class ProductsT(BaseModel):
    __root__: Annotated[
        List[ProductIdT],
        Field(
            description='Specifies a list of product_ids to give context to the parent item.',
            min_items=1,
            title='List of product_ids',
        ),
    ]


class Category7(Enum):
    external = 'external'
    self = 'self'


class ReferencesTItem(BaseModel):
    category: Annotated[
        Optional[Category7],
        Field(
            description=(
                'Indicates whether the reference points to the same document or vulnerability in focus'
                ' (depending on scope) or to an external resource.'
            ),
            title='Category of reference',
        ),
    ] = Category7.external
    summary: Annotated[
        str,
        Field(
            description='Indicates what this reference refers to.',
            min_length=1,
            title='Summary of the reference',
        ),
    ]
    url: Annotated[
        AnyUrl,
        Field(description='Provides the URL for the reference.', title='URL of reference'),
    ]


class ReferencesT(BaseModel):
    __root__: Annotated[
        List[ReferencesTItem],
        Field(
            description='Holds a list of references.',
            min_items=1,
            title='List of references',
        ),
    ]


class VersionT(BaseModel):
    __root__: Annotated[
        str,
        Field(
            description=(
                'Specifies a version string to denote clearly the evolution of the content of the document.'
                ' Format must be either integer or semantic versioning.'
            ),
            examples=['1', '4', '0.9.0', '1.4.3', '2.40.0+21AF26D3'],
            regex=(
                '^(0|[1-9][0-9]*)$|^((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|'
                '\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?'
                '(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?)$'
            ),
            title='Version',
        ),
    ]


class RevisionHistoryItem(BaseModel):
    date: Annotated[
        datetime,
        Field(description='The date of the revision entry', title='Date of the revision'),
    ]
    number: VersionT
    summary: Annotated[
        str,
        Field(
            description='Holds a single non-empty string representing a short description of the changes.',
            examples=['Initial version.'],
            min_length=1,
            title='Summary of the revision',
        ),
    ]


class Tracking(BaseModel):
    aliases: Annotated[
        Optional[List[Alias]],
        Field(
            description='Contains a list of alternate names for the same document.',
            min_items=1,
            title='Aliases',
        ),
    ] = None
    current_release_date: Annotated[
        datetime,
        Field(
            description='The date when the current revision of this document was released',
            title='Current release date',
        ),
    ]
    generator: Annotated[
        Optional[Generator],
        Field(
            description=(
                'Is a container to hold all elements related to the generation of the document.'
                ' These items will reference when the document was actually created,'
                ' including the date it was generated and the entity that generated it.'
            ),
            title='Document generator',
        ),
    ] = None
    id: Annotated[
        str,
        Field(
            description=(
                'The ID is a simple label that provides for a wide range of numbering values, types, and schemes.'
                ' Its value SHOULD be assigned and maintained by the original document issuing authority.'
            ),
            examples=[
                'Example Company - 2019-YH3234',
                'RHBA-2019:0024',
                'cisco-sa-20190513-secureboot',
            ],
            min_length=1,
            title='Unique identifier for the document',
        ),
    ]
    initial_release_date: Annotated[
        datetime,
        Field(
            description='The date when this document was first published.',
            title='Initial release date',
        ),
    ]
    revision_history: Annotated[
        List[RevisionHistoryItem],
        Field(
            description='Holds one revision item for each version of the CSAF document, including the initial one.',
            min_items=1,
            title='Revision history',
        ),
    ]
    status: Annotated[
        Status,
        Field(
            description='Defines the draft status of the document.',
            title='Document status',
        ),
    ]
    version: VersionT


class Document(BaseModel):
    acknowledgments: Annotated[
        Optional[AcknowledgmentsT],
        Field(
            description='Contains a list of acknowledgment elements associated with the whole document.',
            title='Document acknowledgments',
        ),
    ] = None
    aggregate_severity: Annotated[
        Optional[AggregateSeverity],
        Field(
            description=(
                'Is a vehicle that is provided by the document producer to convey the urgency and criticality with'
                ' which the one or more vulnerabilities reported should be addressed.'
                ' It is a document-level metric and applied to the document as a whole'
                ' â€” not any specific vulnerability. The range of values in this field is defined according to the'
                " document producer's policies and procedures."
            ),
            title='Aggregate severity',
        ),
    ] = None
    category: Annotated[
        str,
        Field(
            description=(
                'Defines a short canonical name, chosen by the document producer,'
                ' which will inform the end user as to the category of document.'
            ),
            examples=[
                'Example Company Security Notice',
                'generic_csaf',
                'security_advisory',
                'vex',
            ],
            min_length=1,
            title='Document category',
        ),
    ]
    csaf_version: Annotated[
        CsafVersion,
        Field(
            description='Gives the version of the CSAF specification which the document was generated for.',
            title='CSAF version',
        ),
    ]
    distribution: Annotated[
        Optional[Distribution],
        Field(
            description='Describe any constraints on how this document might be shared.',
            title='Rules for sharing document',
        ),
    ] = None
    lang: Annotated[
        Optional[LangT],
        Field(
            description='Identifies the language used by this document, corresponding to IETF BCP 47 / RFC 5646.',
            title='Document language',
        ),
    ] = None
    notes: Annotated[
        Optional[NotesT],
        Field(
            description='Holds notes associated with the whole document.',
            title='Document notes',
        ),
    ] = None
    publisher: Annotated[
        Publisher,
        Field(
            description='Provides information about the publisher of the document.',
            title='Publisher',
        ),
    ]
    references: Annotated[
        Optional[ReferencesT],
        Field(
            description='Holds a list of references associated with the whole document.',
            title='Document references',
        ),
    ] = None
    source_lang: Annotated[
        Optional[LangT],
        Field(
            description=(
                'If this copy of the document is a translation then the value of this property describes from'
                ' which language this document was translated.'
            ),
            title='Source language',
        ),
    ] = None
    title: Annotated[
        str,
        Field(
            description=(
                'This SHOULD be a canonical name for the document, and sufficiently unique to distinguish it'
                ' from similar documents.'
            ),
            examples=[
                'Cisco IPv6 Crafted Packet Denial of Service Vulnerability',
                'Example Company Cross-Site-Scripting Vulnerability in Example Generator',
            ],
            min_length=1,
            title='Title of this document',
        ),
    ]
    tracking: Annotated[
        Tracking,
        Field(
            description=(
                'Is a container designated to hold all management attributes necessary to track'
                ' a CSAF document as a whole.'
            ),
            title='Tracking',
        ),
    ]


class ProductGroup(BaseModel):
    group_id: ProductGroupIdT
    product_ids: Annotated[
        List[ProductIdT],
        Field(
            description='Lists the product_ids of those products which known as one group in the document.',
            min_items=2,
            title='List of Product IDs',
        ),
    ]
    summary: Annotated[
        Optional[str],
        Field(
            description='Gives a short, optional description of the group.',
            examples=[
                'Products supporting Modbus.',
                'The x64 versions of the operating system.',
            ],
            min_length=1,
            title='Summary of the product group',
        ),
    ] = None


class ProductStatus(BaseModel):
    first_affected: Annotated[
        Optional[ProductsT],
        Field(
            description='These are the first versions of the releases known to be affected by the vulnerability.',
            title='First affected',
        ),
    ] = None
    first_fixed: Annotated[
        Optional[ProductsT],
        Field(
            description=(
                'These versions contain the first fix for the vulnerability but may not be'
                ' the recommended fixed versions.'
            ),
            title='First fixed',
        ),
    ] = None
    fixed: Annotated[
        Optional[ProductsT],
        Field(
            description=(
                'These versions contain a fix for the vulnerability but may not be the recommended fixed versions.'
            ),
            title='Fixed',
        ),
    ] = None
    known_affected: Annotated[
        Optional[ProductsT],
        Field(
            description='These versions are known to be affected by the vulnerability.',
            title='Known affected',
        ),
    ] = None
    known_not_affected: Annotated[
        Optional[ProductsT],
        Field(
            description='These versions are known not to be affected by the vulnerability.',
            title='Known not affected',
        ),
    ] = None
    last_affected: Annotated[
        Optional[ProductsT],
        Field(
            description=(
                'These are the last versions in a release train known to be affected by the vulnerability.'
                ' Subsequently released versions would contain a fix for the vulnerability.'
            ),
            title='Last affected',
        ),
    ] = None
    recommended: Annotated[
        Optional[ProductsT],
        Field(
            description=(
                'These versions have a fix for the vulnerability and are the vendor-recommended versions for'
                ' fixing the vulnerability.'
            ),
            title='Recommended',
        ),
    ] = None
    under_investigation: Annotated[
        Optional[ProductsT],
        Field(
            description=(
                'It is not known yet whether these versions are or are not affected by the vulnerability.'
                ' However, it is still under investigation'
                ' - the result will be provided in a later release of the document.'
            ),
            title='Under investigation',
        ),
    ] = None


class Remediation(BaseModel):
    category: Annotated[
        Category2,
        Field(
            description='Specifies the category which this remediation belongs to.',
            title='Category of the remediation',
        ),
    ]
    date: Annotated[
        Optional[datetime],
        Field(
            description='Contains the date from which the remediation is available.',
            title='Date of the remediation',
        ),
    ] = None
    details: Annotated[
        str,
        Field(
            description='Contains a thorough human-readable discussion of the remediation.',
            min_length=1,
            title='Details of the remediation',
        ),
    ]
    entitlements: Annotated[
        Optional[List[Entitlement]],
        Field(
            description='Contains a list of entitlements.',
            min_items=1,
            title='List of entitlements',
        ),
    ] = None
    group_ids: Optional[ProductGroupsT] = None
    product_ids: Optional[ProductsT] = None
    restart_required: Annotated[
        Optional[RestartRequired],
        Field(
            description=(
                'Provides information on category of restart is required by this remediation to become effective.'
            ),
            title='Restart required by remediation',
        ),
    ] = None
    url: Annotated[
        Optional[AnyUrl],
        Field(
            description='Contains the URL where to obtain the remediation.',
            title='URL to the remediation',
        ),
    ] = None


class Threat(BaseModel):
    category: Annotated[
        Category4,
        Field(
            description='Categorizes the threat according to the rules of the specification.',
            title='Category of the threat',
        ),
    ]
    date: Annotated[
        Optional[datetime],
        Field(
            description='Contains the date when the assessment was done or the threat appeared.',
            title='Date of the threat',
        ),
    ] = None
    details: Annotated[
        str,
        Field(
            description='Represents a thorough human-readable discussion of the threat.',
            min_length=1,
            title='Details of the threat',
        ),
    ]
    group_ids: Optional[ProductGroupsT] = None
    product_ids: Optional[ProductsT] = None


class FullProductNameT(BaseModel):
    name: Annotated[
        str,
        Field(
            description=(
                "The value should be the product's full canonical name, including version number and other attributes,"
                ' as it would be used in a human-friendly document.'
            ),
            examples=[
                'Cisco AnyConnect Secure Mobility Client 2.3.185',
                'Microsoft Host Integration Server 2006 Service Pack 1',
            ],
            min_length=1,
            title='Textual description of the product',
        ),
    ]
    product_id: ProductIdT
    product_identification_helper: Annotated[
        Optional[ProductIdentificationHelper],
        Field(
            description='Provides at least one method which aids in identifying the product in an asset database.',
            title='Helper to identify the product',
        ),
    ] = None


class Relationship(BaseModel):
    category: Annotated[
        Category1,
        Field(
            description='Defines the category of relationship for the referenced component.',
            title='Relationship category',
        ),
    ]
    full_product_name: FullProductNameT
    product_reference: Annotated[
        ProductIdT,
        Field(
            description=(
                'Holds a Product ID that refers to the Full Product Name element, which is referenced as'
                ' the first element of the relationship.'
            ),
            title='Product reference',
        ),
    ]
    relates_to_product_reference: Annotated[
        ProductIdT,
        Field(
            description=(
                'Holds a Product ID that refers to the Full Product Name element, which is referenced as'
                ' the second element of the relationship.'
            ),
            title='Relates to product reference',
        ),
    ]


class Score(BaseModel):
    cvss2: Optional[cvss_v2.Field0] = None
    cvss3: Optional[Union[cvss_v3.Field0, cvss_v3.Field1]] = None
    products: ProductsT


class Vulnerability(BaseModel):
    acknowledgments: Annotated[
        Optional[AcknowledgmentsT],
        Field(
            description='Contains a list of acknowledgment elements associated with this vulnerability item.',
            title='Vulnerability acknowledgments',
        ),
    ] = None
    cve: Annotated[
        Optional[str],
        Field(
            description=(
                'Holds the MITRE standard Common Vulnerabilities and Exposures (CVE) tracking number for'
                ' the vulnerability.'
            ),
            regex='^CVE-[0-9]{4}-[0-9]{4,}$',
            title='CVE',
        ),
    ] = None
    cwe: Annotated[
        Optional[Cwe],
        Field(
            description='Holds the MITRE standard Common Weakness Enumeration (CWE) for the weakness associated.',
            title='CWE',
        ),
    ] = None
    discovery_date: Annotated[
        Optional[datetime],
        Field(
            description='Holds the date and time the vulnerability was originally discovered.',
            title='Discovery date',
        ),
    ] = None
    id: Annotated[
        Optional[Id],
        Field(
            description=(
                'Gives the document producer a place to publish a unique label or tracking ID for the vulnerability'
                ' (if such information exists).'
            ),
            title='ID',
        ),
    ] = None
    involvements: Annotated[
        Optional[List[Involvement]],
        Field(
            description='Contains a list of involvements.',
            min_items=1,
            title='List of involvements',
        ),
    ] = None
    notes: Annotated[
        Optional[NotesT],
        Field(
            description='Holds notes associated with this vulnerability item.',
            title='Vulnerability notes',
        ),
    ] = None
    product_status: Annotated[
        Optional[ProductStatus],
        Field(
            description=(
                'Contains different lists of product_ids which provide details on the status of'
                ' the referenced product related to the current vulnerability. '
            ),
            title='Product status',
        ),
    ] = None
    references: Annotated[
        Optional[ReferencesT],
        Field(
            description='Holds a list of references associated with this vulnerability item.',
            title='Vulnerability references',
        ),
    ] = None
    release_date: Annotated[
        Optional[datetime],
        Field(
            description='Holds the date and time the vulnerability was originally released into the wild.',
            title='Release date',
        ),
    ] = None
    remediations: Annotated[
        Optional[List[Remediation]],
        Field(
            description='Contains a list of remediations.',
            min_items=1,
            title='List of remediations',
        ),
    ] = None
    scores: Annotated[
        Optional[List[Score]],
        Field(
            description='contains score objects for the current vulnerability.',
            min_items=1,
            title='List of scores',
        ),
    ] = None
    threats: Annotated[
        Optional[List[Threat]],
        Field(
            description='Contains information about a vulnerability that can change with time.',
            min_items=1,
            title='List of threats',
        ),
    ] = None
    title: Annotated[
        Optional[str],
        Field(
            description=(
                'Gives the document producer the ability to apply a canonical name or title to the vulnerability.'
            ),
            min_length=1,
            title='Title',
        ),
    ] = None


class ProductTree(BaseModel):
    branches: Optional[BranchesT] = None
    full_product_names: Annotated[
        Optional[List[FullProductNameT]],
        Field(
            description='Contains a list of full product names.',
            min_items=1,
            title='List of full product names',
        ),
    ] = None
    product_groups: Annotated[
        Optional[List[ProductGroup]],
        Field(
            description='Contains a list of product groups.',
            min_items=1,
            title='List of product groups',
        ),
    ] = None
    relationships: Annotated[
        Optional[List[Relationship]],
        Field(
            description='Contains a list of relationships.',
            min_items=1,
            title='List of relationships',
        ),
    ] = None


class CSAF(BaseModel):
    document: Annotated[
        Document,
        Field(
            description=(
                'Captures the meta-data about this document describing a particular set of security advisories.'
            ),
            title='Document level meta-data',
        ),
    ]
    product_tree: Annotated[
        Optional[ProductTree],
        Field(
            description=(
                'Is a container for all fully qualified product names that can be referenced elsewhere in the document.'
            ),
            title='Product tree',
        ),
    ] = None
    vulnerabilities: Annotated[
        Optional[List[Vulnerability]],
        Field(
            description='Represents a list of all relevant vulnerability information items.',
            min_items=1,
            title='Vulnerabilities',
        ),
    ] = None


class BranchesTItem(BaseModel):
    branches: Optional[BranchesT] = None
    category: Annotated[
        Category5,
        Field(
            description='Describes the characteristics of the labeled branch.',
            title='Category of the branch',
        ),
    ]
    name: Annotated[
        str,
        Field(
            description="Contains the canonical descriptor or 'friendly name' of the branch.",
            examples=[
                '10',
                '365',
                'Microsoft',
                'Office',
                'PCS 7',
                'SIMATIC',
                'Siemens',
                'Windows',
            ],
            min_length=1,
            title='Name of the branch',
        ),
    ]
    product: Optional[FullProductNameT] = None


class BranchesT(BaseModel):
    __root__: Annotated[
        List[BranchesTItem],
        Field(
            description='Contains branch elements as children of the current element.',
            min_items=1,
            title='List of branches',
        ),
    ]


ProductTree.update_forward_refs()
BranchesTItem.update_forward_refs()
